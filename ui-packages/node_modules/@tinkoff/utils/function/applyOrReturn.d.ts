declare type ApplyFunc<T> = (...args: T[]) => any;
interface ApplyOrReturn {
    <T, F extends ApplyFunc<T>>(args: T[], test: F): ReturnType<F>;
    <T, F>(args: T[], test: F extends Function ? ApplyFunc<T> : F): F;
    <T>(args: T[]): <F extends ApplyFunc<T>>(test: F) => ReturnType<F>;
    <T>(args: T[]): <F>(test: F extends Function ? ApplyFunc<T> : F) => F;
}
/**
 * If `test` is function it calls with applied first argument, otherwise just returns `test`
 *
 * @param {Array} args Arguments passed to `test` if it's a function
 * @param {*} test if `test` is function it's called with `args`
 * @return {*}
 * @example
 *
 *      applyOrReturn([1,2,3], (...args) => args) // => [1,2,3]
 *      applyOrReturn([1,2,3], 'test') // => 'test'
 */
declare const _default: ApplyOrReturn;
export default _default;

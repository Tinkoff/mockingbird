interface DeepSizeLimit {
    <T extends Function>(maxSize: number, fn: T): T;
    (maxSize: number): <T extends Function>(fn: T) => T;
}
/**
 * Memoize function with multiply arguments of any type, but it
 * clears cache every time it reaches the limit. Use it when you need
 * deep equality for cache lookup and afraid of memory leak.
 *
 * @param {Number} sizeLimit. Cache size limit
 * @returns {Function} fn
 * @example
 *     const addFlag = obj => ({...obj, flag: true });
 *     const memoize = memoizeDeepSizeLimit(2, addFlag));
 *     memoize({test: 2}); // from addFlag call
 *     memoize({test: 2}); // from cache
 *     memoize({test: 3}); //from addFlag call
 *     memoize({test: 4}); // from addFlag call
 *     memoize({test: 2}); // from addFlag call (memory was cleared)
 */
declare const _default: DeepSizeLimit;
export default _default;
